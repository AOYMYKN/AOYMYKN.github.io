<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>关于Spring的IoC和AOP - AOYMYKN的博客</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="AOYMYKN" /><meta name="description" content="进行一个spring的学，先去了解下它最重要的两项功能——IoC和AOP。" /><meta name="keywords" content="Java, 后端, 计算机, 编程, 数据结构, 算法, CS, IT" />






<meta name="generator" content="Hugo 0.81.0 with theme even" />


<link rel="canonical" href="http://aoymykn.github.io/post/2021/%E5%85%B3%E4%BA%8Espring%E7%9A%84ioc%E5%92%8Caop/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.8bb66a6c962ec1755867d3d5ce8e5267f80d5dc80d7d74f19be0b9686de4c75f.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="关于Spring的IoC和AOP" />
<meta property="og:description" content="进行一个spring的学，先去了解下它最重要的两项功能——IoC和AOP。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://aoymykn.github.io/post/2021/%E5%85%B3%E4%BA%8Espring%E7%9A%84ioc%E5%92%8Caop/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-06-29T15:21:40&#43;08:00" />
<meta property="article:modified_time" content="2021-06-29T15:21:40&#43;08:00" />

<meta itemprop="name" content="关于Spring的IoC和AOP">
<meta itemprop="description" content="进行一个spring的学，先去了解下它最重要的两项功能——IoC和AOP。"><meta itemprop="datePublished" content="2021-06-29T15:21:40&#43;08:00" />
<meta itemprop="dateModified" content="2021-06-29T15:21:40&#43;08:00" />
<meta itemprop="wordCount" content="5279">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="关于Spring的IoC和AOP"/>
<meta name="twitter:description" content="进行一个spring的学，先去了解下它最重要的两项功能——IoC和AOP。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">AOYMYKN</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">AOYMYKN</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">关于Spring的IoC和AOP</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-06-29 </span>
        <div class="post-category">
            <a href="/categories/spring/"> Spring </a>
            </div>
          <span class="more-meta"> 约 5279 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#spring是什么">Spring是什么</a></li>
    <li><a href="#ioc是什么以及其的意义">IoC是什么以及其的意义</a></li>
    <li><a href="#ioc的使用">IoC的使用</a></li>
    <li><a href="#关于注入的方式">关于注入的方式</a></li>
    <li><a href="#静态代理">静态代理</a></li>
    <li><a href="#动态代理">动态代理</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <!--Hello, Happy World-->
<p>虽然毕设后端使用的是Spring Boot，但我实际上对Spring斌没有真正的了解过，也就能敲一些业务代码罢了（比较重要的测试也不会用）。现在为准备工作，学一些Spring基础，顺便做一些笔记。这里只是粗糙地了解一下，等真正熟练使用了再去了解更深层的东西。</p>
<h1 id="spring是什么">Spring是什么</h1>
<p>Spring是什么？它是什么条件下产生的，基于怎样的理念，提供了什么功能，解决了什么问题？这几个问题是重要的，但是我目前可没法全部回答。</p>
<p>就本质来说，Spring是一个<strong>后端框架</strong>，可用于编写服务端应用，桌面端应用（哪有人这么用！），同分布式，微服务等进行结合也是容易的，它是非侵入式的。Spring也提供了各种功能丰富的框架——Web，安全，模板，持久化，运行时监控等，其也容易和很多其它java库结合使用。</p>
<p>应用程序是由许多组件构成的，每个组件都负责一部分功能，一般来说其会通过和其他组件进行协调和交互来完成自己的任务（和OOP很相似）。Spring的核心是提供了一个<strong>容器</strong>——<strong>Spring应用上下文（Spring Application Context）</strong>，其将对应用程序中各组件进行创建和管理，最终<strong>装配</strong>到一起。被管理的组件称为<strong>bean</strong>。</p>
<p>为什么要将组件的生命周期交给Spring容器进行管理？为了实现所谓的<strong>控制反转（IoC，Inversion of Control）</strong>，对程序进行解耦，同时让组件更加专注于业务——不需要负责依赖对象的创建和管理了，具体见下。</p>
<p>这种装配的过程是通过**依赖注入（DI，Dependency Injection）**实现的，对每个bean，容器将对其的所有依赖（即其持有的其它bean）进行注入。可以认为Spring应用上下文所维护的就是各个bean（或者说各个组件）的生命周期及其相互关系。</p>
<p>装配的配置可以使用xml或java类，但最常用的仍旧是自动装配——Spring自动发现包中的组件并进行装配。</p>
<h1 id="ioc是什么以及其的意义">IoC是什么以及其的意义</h1>
<p>IoC（控制反转）即对所需对象的创建不由程序进行，而是由用户进行，将控制权交由用户，Spring中的IoC即是将对象的创建，管理交由Spring提供的IoC容器进行，其实现的方式是DI（依赖注入）。IoC可以认为是工厂方法模式的一种应用。</p>
<p>就如大多数特定的技术一样，IoC的意义也在于对程序解耦合，提高程序的可维护性。</p>
<p>考虑这样一个场景，在某个Service里通过DAO层获取用户信息。这里系统使用了MySQl作为数据库。于是得到了这样的代码——</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="k">interface</span> <span class="nc">UserService</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">getUser</span><span class="p">():</span> <span class="n">User</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">interface</span> <span class="nc">UserDao</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">getUser</span><span class="p">():</span> <span class="n">User</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">UserDaoMySQLImpl</span> <span class="p">:</span> <span class="n">UserDao</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">getUser</span><span class="p">():</span> <span class="n">User</span> <span class="p">{</span>
        <span class="n">println</span><span class="p">(</span><span class="s2">&#34;查询了MySQL&#34;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">User</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">UserServiceImpl</span> <span class="p">:</span> <span class="n">UserService</span> <span class="p">{</span>
    <span class="k">private</span> <span class="k">val</span> <span class="py">userDao</span> <span class="p">:</span> <span class="n">UserDao</span> <span class="p">=</span> <span class="n">UserDaoMySQLImpl</span><span class="p">()</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">getUser</span><span class="p">():</span> <span class="n">User</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">userDao</span><span class="p">.</span><span class="n">getUser</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后，出于某种奇怪的业务需要，系统又换成了SQL Server数据库，然后下面的程序员就编写了UserDaoSQLServerImpl，并把各种Service里的所有的UserDaoMySQLImpl改成UserDaoSQLServerImpl。</p>
<p>再然后，需求又改了，要用sqlite数据库了，于是程序员们又重复了上面的步骤，周而复始……</p>
<p>于是可以看到问题，每次需求一改变，都要改源代码，这里的问题在于，各种serviceImpl实际上和各种daoImpl是<strong>紧耦合</strong>的，要更换使用的dao就必须侵入式地修改代码，显然这里可以使用工厂方法模式，通过反射和配置文件生成相应的类。</p>
<p>但是这里先不提工厂方法模式，一个比较简单的修改方式是，将使用哪个daoImpl的权力交给“用户”（使用相关类的代码），让用户通过构造器或set方法，对想要使用的dao进行设定。如下面的形式——</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="k">class</span> <span class="nc">UserServiceImpl</span> <span class="p">:</span> <span class="n">UserService</span> <span class="p">{</span>
    <span class="k">private</span> <span class="k">var</span> <span class="py">userDao</span> <span class="p">:</span> <span class="n">UserDao</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>
    <span class="k">fun</span> <span class="nf">setUserDao</span><span class="p">(</span><span class="n">userDao</span> <span class="p">:</span> <span class="n">UserDao</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">userDao</span> <span class="p">=</span> <span class="n">userDao</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">getUser</span><span class="p">():</span> <span class="n">User</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">userDao</span><span class="o">?.</span><span class="n">getUser</span><span class="p">()</span><span class="o">!!</span> <span class="c1">// 这里写的非常不优雅
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 假设这是用户代码
</span><span class="c1"></span><span class="k">fun</span> <span class="nf">userCode</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">userService</span> <span class="p">:</span> <span class="n">UserService</span> <span class="p">=</span> <span class="n">UserServiceImpl</span><span class="p">()</span>
    <span class="p">(</span><span class="n">userService</span> <span class="k">as</span> <span class="n">UserServiceImpl</span><span class="p">).</span><span class="n">setUserDao</span><span class="p">(</span><span class="n">UserDaoMySQLImpl</span><span class="p">())</span> <span class="c1">// 在这里注入
</span><span class="c1"></span>    <span class="n">userService</span><span class="p">.</span><span class="n">getUser</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>用户想用mySQL？想用SQL Server？自己选择相应的实现就是了！这就是所谓的控制权交给用户，即控制反转的一个示例。更换实现也不需要改变源代码了。</p>
<h1 id="ioc的使用">IoC的使用</h1>
<p>在Spring中，对象创建的控制权交给了IoC容器，被接管的对象称为<strong>Bean</strong>。用户需要通过xml，Java代码或注解对Bean进行配置。使用时，根据xml或其它形式获取相关配置的上下文，并手动或自动对Bean进行获取，下面是一个手动获取Bean的示例。</p>
<p>IoC容器接管的类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// DAO层
</span><span class="c1"></span><span class="kd">interface</span> <span class="nc">HelloDao</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">getHappyEnergy</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloDaoImpl</span> <span class="kd">implements</span> <span class="n">HelloDao</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">getHappyEnergy</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Happy, Lucky, Smile, Yeah!&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// Service层
</span><span class="c1"></span><span class="kd">interface</span> <span class="nc">HelloService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">getHappyEnergy</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloServiceImpl</span> <span class="kd">implements</span> <span class="n">HelloService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">HelloDao</span> <span class="n">helloDao</span><span class="o">;</span>
    <span class="c1">// 用于注入的setter，必须要有此方法，Spring才能进行依赖注入，或者使用Autowired注解域也可，Spring将通过反射设置属性。
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setHelloDao</span><span class="o">(</span><span class="n">HelloDao</span> <span class="n">helloDao</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">helloDao</span> <span class="o">=</span> <span class="n">helloDao</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">getHappyEnergy</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">helloDao</span><span class="o">.</span><span class="na">getHappyEnergy</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>xml文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="c">&lt;!-- ApplicationContext.xml --&gt;</span>
<span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">&#34;http://www.springframework.org/schema/beans&#34;</span>
       <span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
       <span class="na">xmlns:p=</span><span class="s">&#34;http://www.springframework.org/schema/p&#34;</span>
       <span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&#34;</span><span class="nt">&gt;</span>

    <span class="c">&lt;!-- bean在这里定义，要修改使用的实现？修改class即可！
</span><span class="c">    这里还能够进行更加精细的配置，如通过构造器参数配置，
</span><span class="c">    对每个成员进行配置（各种容器类也提供了相应的配置标签），
</span><span class="c">    其成员也可以引用其它Bean，从而让各实现类能够相互引用，
</span><span class="c">    也可在此配置autowire，令IoC进行自动注入 --&gt;</span>

    <span class="c">&lt;!-- 也可通过注解和component-scan，annotation-config这两个注解进行自动注入 --&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;helloDao&#34;</span> <span class="na">class=</span><span class="s">&#34;xyz.yukina.dao.HelloDaoImpl&#34;</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;helloService&#34;</span> <span class="na">class=</span><span class="s">&#34;xyz.yukina.service.HelloServiceImpl&#34;</span> <span class="na">p:helloDao-ref=</span><span class="s">&#34;helloDao&#34;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>用户代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// ClassPathXmlApplicationContext——通过xml获取配置，简写CPX
</span><span class="c1"></span>    <span class="n">ApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">&#34;ApplicationContext.xml&#34;</span><span class="o">);</span>
    <span class="n">HelloService</span> <span class="n">helloService</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">&#34;helloService&#34;</span><span class="o">,</span> <span class="n">HelloService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">helloService</span><span class="o">.</span><span class="na">getHappyEnergy</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可见，现在用户要获取的实例是通过配置文件给定的，而对配置文件的修改是不需要修改源代码的，这就让各个模块解耦了——在使用IoC之前，各个模块是紧密相连，需要手动处理（new）相互的依赖关系，使用IoC容器后，它们<strong>实际上只需要与IoC容器交互</strong>即可，这样互相的耦合性就降低了，且用户也可以不必关心自己究竟用的是哪个具体类，提高了系统的抽象性。且将对象的创建和管理交管给IoC容器，这也让容器对对象进行特定的处理也成为可能，或许AOP就是在此条件下实现的吧！</p>
<p>需要注意的是，Bean默认是<strong>单例</strong>的，<strong>非惰性</strong>的——在执行<code>new ClassPathXmlApplicationContext(&quot;ApplicationContext.xml&quot;)</code>时，所有bean默认将被初始化而无论是否使用。</p>
<h1 id="关于注入的方式">关于注入的方式</h1>
<p>Spring提供的注入方式有三种——域注入，set注入，构造器注入。默认在xml中进行配置的话使用的是set注入和构造器注入，将Autowired注解作用到域中则是域注入。Spring不推荐使用域注入。</p>
<p>Spring推荐使用构造器注入，其次是set注入，其中构造器注入用于注入必需的（不为null）依赖，set注入用于注入可选的，或者给定默认值的依赖。kotlin推荐的方式也是构造器注入。构造器注入的优势在于其能够定义注入对象为final（或者kotlin的val），语义更加明确。</p>
<p>其中，对于构造器注入，Spring推荐使用断言来保证为非null。一个示例如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloServiceImpl</span> <span class="kd">implements</span> <span class="n">HelloService</span> <span class="o">{</span>
    <span class="nd">@Autowired</span> <span class="c1">// 域注入
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">AbcDao</span> <span class="n">abcDao</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">AnotherDao</span> <span class="n">anotherDao</span><span class="o">;</span>
    <span class="nd">@Autowired</span> <span class="c1">// set注入
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAnotherDao</span><span class="o">(</span><span class="n">AnotherDao</span> <span class="n">anotherDao</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">anotherDao</span> <span class="o">=</span> <span class="n">anotherDao</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="n">HelloDao</span> <span class="n">helloDao</span><span class="o">;</span>
    <span class="nd">@Autowired</span> <span class="c1">// 构造器注入
</span><span class="c1"></span>    <span class="kd">public</span> <span class="nf">HelloServiceImpl</span><span class="o">(</span>
        <span class="nd">@Qualifier</span><span class="o">(</span><span class="s">&#34;HelloDaoImpl&#34;</span><span class="o">)</span> <span class="n">HelloDao</span> <span class="n">helloDao</span> <span class="c1">// 如果有歧义，可以在这里用Qualifier注解
</span><span class="c1"></span>    <span class="o">)</span> <span class="o">{</span>
        <span class="k">assert</span> <span class="n">helloDao</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">HelloDao</span> <span class="o">=</span> <span class="n">helloDao</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">getHappyEnergy</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">helloDao</span><span class="o">.</span><span class="na">getHappyEnergy</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="静态代理">静态代理</h1>
<p>Spring的AOP的实现利用了<strong>代理模式</strong>。实际上我在编写毕设时已经接触过了代理模式——vue的ref对象将原对象的get和set方法进行<strong>劫持</strong>（我觉得这个词更加形象）以保证监听数据改变，这样，在操作ref对象的时候，我们采用和普通对象一样的方式，而vue则在后台做更多的操作，如更新视图，维护相关计算属性，方法，监听器等。</p>
<p>在这里，代理模式的作用在于，真实角色（即原对象）的操作完全不需要关心任何视图层的事情，简单纯粹，而相应的业务交由代理角色（ref对象）执行，容易进行维护和扩展。代码的编写者只需要对代理角色像真实角色一样进行操作即可，摆脱了手动管理DOM的麻烦。我认为<strong>代理模式最大的意义在于，通过特定的抽象，客户端可以完全不用关注自己所使用的是真实角色还是代理角色，从而提高了系统的抽象程度</strong>。</p>
<p>代理模式有四个角色：</p>
<ol>
<li><strong>接口</strong></li>
</ol>
<p>接口代表真实角色需要进行代理的方法。在vue中，这些方法是对象的各个属性的get和set，因此这里的接口角色是隐含的。</p>
<ol start="2">
<li><strong>真实角色</strong></li>
</ol>
<p>真实角色即为被代理的角色，它应当实现接口。</p>
<ol start="3">
<li><strong>代理角色</strong></li>
</ol>
<p>代理角色应当持有真实角色（通过<strong>组合</strong>和继承均可，组合最优，这时就通过<strong>委托</strong>进行代理；这里我认为使用继承在语义上更加符合）并实现接口，在接口中，除调用真实角色的相应方法，也应加入自身的处理。代理角色和真实角色都实现接口，以保证其提供的API一致。</p>
<ol start="4">
<li><strong>客户端</strong></li>
</ol>
<p>客户端为调用接口的角色，在这里，客户端应当使用代理角色，并期待它通过真实角色进行操作时同时执行自己的业务。</p>
<p>AOP其实就是这样的东西——它对特定对象进行<strong>切入</strong>，在这些对象执行特定方法时能够进行“劫持”，添加进自己的操作，比如输出，计数，监控 <del>，发给某些企业</del> 等，甚至可修改传递给原对象的方法的参数。将方法标识为事务也是利用了AOP。下面编写了一个实例——通过代理对原有操作进行计数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">MyService</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">MyServiceImpl</span> <span class="kd">implements</span> <span class="n">MyService</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;做点什么事&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">ServiceProxy</span> <span class="kd">implements</span> <span class="n">MyService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">MyService</span> <span class="n">myService</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">ServiceProxy</span><span class="o">(</span><span class="n">MyService</span> <span class="n">myService</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">myService</span> <span class="o">=</span> <span class="n">myService</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;第&#34;</span><span class="o">+(++</span><span class="n">counter</span><span class="o">)+</span><span class="s">&#34;次执行&#34;</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;执行前&#34;</span><span class="o">);</span>
        <span class="n">myService</span><span class="o">.</span><span class="na">doSomething</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;执行后&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">MyService</span> <span class="n">myService</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyServiceImpl</span><span class="o">();</span> <span class="c1">// 也可以不暴露原对象给客户端
</span><span class="c1"></span>        <span class="n">MyService</span> <span class="n">myServiceProxy</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ServiceProxy</span><span class="o">(</span><span class="n">myService</span><span class="o">);</span>
        <span class="n">myServiceProxy</span><span class="o">.</span><span class="na">doSomething</span><span class="o">();</span>
        <span class="n">myServiceProxy</span><span class="o">.</span><span class="na">doSomething</span><span class="o">();</span>
        <span class="n">myServiceProxy</span><span class="o">.</span><span class="na">doSomething</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="动态代理">动态代理</h1>
<p>上面所说的是静态代理模式——代理角色是写死的，而还存在动态代理模式——动态生成代理角色（vue的例子应当也是动态代理）。动态代理分为<strong>基于接口的动态代理</strong>和<strong>基于类的动态代理</strong>。</p>
<p>动态代理其实就是利用反射对方法调用进行劫持。这里展示了一个代理handler的例子，它劫持所有方法调用，在方法执行前和执行后都进行输出。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">
<span class="c1">// 代理handler，每个handler都应当有自己的业务
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProxyInvocationHandler</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>
    <span class="c1">// 获取代理实例
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Object</span> <span class="nf">getProxyInstance</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">(),</span> <span class="n">obj</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getInterfaces</span><span class="o">(),</span>  <span class="k">new</span> <span class="n">ProxyInvocationHandler</span><span class="o">(</span><span class="n">obj</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="c1">// handler是和被代理对象一一对应的，这非常让人误解
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">Object</span> <span class="n">t</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">ProxyInvocationHandler</span><span class="o">(</span><span class="nd">@NotNull</span> <span class="n">Object</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="c1">// 对象进行方法调用时，实际调用的是这个方法
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;执行前&#34;</span><span class="o">);</span>
        <span class="n">Object</span> <span class="n">res</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;执行后&#34;</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 业务代码
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 也可通过给定Class的方法避免强转，但是这语法我不会
</span><span class="c1"></span>        <span class="n">UserService</span> <span class="n">serviceProxy</span> <span class="o">=</span> <span class="o">(</span><span class="n">UserService</span><span class="o">)</span> <span class="n">ProxyInvocationHandler</span><span class="o">.</span><span class="na">getProxyInstance</span><span class="o">(</span><span class="k">new</span> <span class="n">UserServiceImpl</span><span class="o">());</span>
        <span class="n">serviceProxy</span><span class="o">.</span><span class="na">add</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个代理handler可以进一步抽象成更加一般的形式——要求用户给定方法执行前，执行后将要执行的代码，给定对args的处理，给定对输出结果的处理……这里按本人想法进行了一些编码。相信Spring的AOP对此有更加具有实践性和更优雅的实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 考虑到要持有对象，使用抽象类而非接口
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">ProxyHandler</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Object</span> <span class="n">obj</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">ProxyHandler</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">before</span><span class="o">()</span> <span class="o">{};</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">after</span><span class="o">()</span> <span class="o">{};</span>
    <span class="kd">public</span> <span class="n">Object</span><span class="o">[]</span> <span class="nf">parseArg</span><span class="o">(</span><span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">args</span><span class="o">;};</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">parseRes</span><span class="o">(</span><span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InvocationTargetException</span><span class="o">,</span> <span class="n">IllegalAccessException</span> <span class="o">{</span><span class="k">return</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">obj</span><span class="o">,</span> <span class="n">args</span><span class="o">);};</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
        <span class="c1">// 这里可以根据method.getName对代理的方法做限定
</span><span class="c1"></span>        <span class="n">before</span><span class="o">();</span>
        <span class="c1">// 在某些情形，比如缓存时，甚至可以不调用原方法！
</span><span class="c1"></span>        <span class="n">Object</span> <span class="n">res</span> <span class="o">=</span> <span class="n">parseRes</span><span class="o">(</span><span class="n">method</span><span class="o">,</span> <span class="n">parseArg</span><span class="o">(</span><span class="n">method</span><span class="o">,</span> <span class="n">args</span><span class="o">));</span>
        <span class="n">after</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 考虑到如果使用static，则无法直接引用到类的class，这里被迫使用抽象程度比较低的写法，同样的，这里可以整个class作为参数
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Object</span> <span class="nf">getProxyInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">(),</span> <span class="n">obj</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getInterfaces</span><span class="o">(),</span> <span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 一个代理的定义
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CounterProxy</span> <span class="kd">extends</span> <span class="n">ProxyHandler</span><span class="o">{</span>
    <span class="kd">public</span> <span class="nf">CounterProxy</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">startTime</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">endTime</span><span class="o">;</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">before</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;执行前&#34;</span><span class="o">);</span>
        <span class="n">startTime</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>    <span class="c1">//获取开始时间
</span><span class="c1"></span>    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">after</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">endTime</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>    <span class="c1">//获取开始时间
</span><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;执行后&#34;</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;程序运行时间： &#34;</span><span class="o">+(</span><span class="n">endTime</span><span class="o">-</span><span class="n">startTime</span><span class="o">)+</span><span class="s">&#34;ns&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 业务代码
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 考虑到能够让用户不了解ProxyHandler便可编写新的代理，我觉得这种抽象程度已经足够
</span><span class="c1"></span>    <span class="c1">// 但若是容忍每次编写新的代理类时都把getProxyInstance静态方法重写一次，则可使用更加优雅的写法（伴生对象能不能解决这一问题？）
</span><span class="c1"></span>    <span class="c1">// 当然，或许更优的方式则是通过工厂方法模式获取相应Class并进行操作，这理论上可以通过注解或配置文件进行，应该是非常好的一个解决方案。
</span><span class="c1"></span>    <span class="n">UserService</span> <span class="n">service</span> <span class="o">=</span> <span class="o">(</span><span class="n">UserService</span><span class="o">)</span> <span class="k">new</span> <span class="n">CounterProxy</span><span class="o">(</span><span class="k">new</span> <span class="n">UserServiceImpl</span><span class="o">()).</span><span class="na">getProxyInstance</span><span class="o">();</span>
    <span class="n">service</span><span class="o">.</span><span class="na">add</span><span class="o">();</span>
    <span class="n">service</span><span class="o">.</span><span class="na">delete</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>AOP的具体使用方法不再研究了，先研究其他更重要的东西去。</p>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/2021/06-29%E5%85%B3%E4%BA%8E%E7%AC%AC%E4%B8%80%E5%B9%B4%E7%9A%84%E8%AE%A1%E5%88%92/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">关于工作第一年的计划</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/2021/06-27%E5%85%B3%E4%BA%8E%E6%AF%95%E8%AE%BE%E7%9A%84%E6%80%BB%E7%BB%93/">
            <span class="next-text nav-default">关于毕设的总结</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '2021-06-29 15:21:40 \u002b0800 CST',
        title: '关于Spring的IoC和AOP',
        clientID: 'a6d39dcb11d3911b23d9',
        clientSecret: 'a1b3afce97c2b2c21ef8ad1f40b0fce20a334be0',
        repo: 'comments',
        owner: 'AOYMYKN',
        admin: ['AOYMYKN'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:cs596065766@hotmail.com" class="iconfont icon-email" title="email"></a>
  <a href="http://aoymykn.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2020 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>AOYMYKN</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>








</body>
</html>
